// Generated by gtkmmproc -- DO NOT MODIFY!


#include <libmidgard2mm/libmidgard2.h>
#include <libmidgard2mm/private/libmidgard2_p.h>

/* Copyright (c) 2010  Joe Hacker <joe@example.com>
 *
 * This file is part of libmidgard2mm.
 *
 * libmidgard2mm is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 2.1 of the License,
 * or (at your option) any later version.
 *
 * libmidgard2mm is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

namespace Midgard
{

} // namespace Midgard

namespace
{
} // anonymous namespace


namespace Glib
{

Glib::RefPtr<Midgard::Config> wrap(MidgardConfig* object, bool take_copy)
{
  return Glib::RefPtr<Midgard::Config>( dynamic_cast<Midgard::Config*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Midgard
{


/* The *_Class implementation: */

const Glib::Class& Config_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Config_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(midgard_type_config_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void Config_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED

#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
}

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED

#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED


Glib::ObjectBase* Config_Class::wrap_new(GObject* object)
{
  return new Config((MidgardConfig*)object);
}


/* The implementation: */

MidgardConfig* Config::gobj_copy()
{
  reference();
  return gobj();
}

Config::Config(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{

}

Config::Config(MidgardConfig* castitem)
:
  Glib::Object((GObject*)(castitem))
{}


Config::~Config()
{}


Config::CppClassType Config::config_class_; // initialize static member

GType Config::get_type()
{
  return config_class_.init().get_type();
}


GType Config::get_base_type()
{
  return midgard_type_config_get_type();
}


Config::Config()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(0),
  Glib::Object(Glib::ConstructParams(config_class_.init()))
{
  

}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
void Config::read_file(const Glib::ustring& name, bool user_file)
#else
void Config::read_file(const Glib::ustring& name, bool user_file, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  midgard_config_read_file(gobj(), name.c_str(), static_cast<int>(user_file), &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED


}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
void Config::save_file(const Glib::ustring& name, bool user_file)
#else
void Config::save_file(const Glib::ustring& name, bool user_file, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  midgard_config_save_file(gobj(), name.c_str(), static_cast<int>(user_file), &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED


}

void Config::create_blobdir()
{
midgard_config_create_blobdir(gobj()); 
}

#ifdef GLIBMM_EXCEPTIONS_ENABLED
void Config::read_file_at_path(const Glib::ustring& name)
#else
void Config::read_file_at_path(const Glib::ustring& name, std::auto_ptr<Glib::Error>& error)
#endif //GLIBMM_EXCEPTIONS_ENABLED
{
  GError* gerror = 0;
  midgard_config_read_file_at_path(gobj(), name.c_str(), &(gerror));
#ifdef GLIBMM_EXCEPTIONS_ENABLED
  if(gerror)
    ::Glib::Error::throw_exception(gerror);
#else
  if(gerror)
    error = ::Glib::Error::throw_exception(gerror);
#endif //GLIBMM_EXCEPTIONS_ENABLED


}


#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED


} // namespace Midgard


namespace Glib
{

Glib::RefPtr<Midgard::Connection> wrap(MidgardConnection* object, bool take_copy)
{
  return Glib::RefPtr<Midgard::Connection>( dynamic_cast<Midgard::Connection*> (Glib::wrap_auto ((GObject*)(object), take_copy)) );
  //We use dynamic_cast<> in case of multiple inheritance.
}

} /* namespace Glib */


namespace Midgard
{


/* The *_Class implementation: */

const Glib::Class& Connection_Class::init()
{
  if(!gtype_) // create the GType if necessary
  {
    // Glib::Class has to know the class init function to clone custom types.
    class_init_func_ = &Connection_Class::class_init_function;

    // This is actually just optimized away, apparently with no harm.
    // Make sure that the parent type has been created.
    //CppClassParent::CppObjectType::get_type();

    // Create the wrapper type, with the same class/instance size as the base type.
    register_derived_type(midgard_type_connection_get_type());

    // Add derived versions of interfaces, if the C type implements any interfaces:

  }

  return *this;
}


void Connection_Class::class_init_function(void* g_class, void* class_data)
{
  BaseClassType *const klass = static_cast<BaseClassType*>(g_class);
  CppClassParent::class_init_function(klass, class_data);

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED

#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
}

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED

#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED


Glib::ObjectBase* Connection_Class::wrap_new(GObject* object)
{
  return new Connection((MidgardConnection*)object);
}


/* The implementation: */

MidgardConnection* Connection::gobj_copy()
{
  reference();
  return gobj();
}

Connection::Connection(const Glib::ConstructParams& construct_params)
:
  Glib::Object(construct_params)
{

}

Connection::Connection(MidgardConnection* castitem)
:
  Glib::Object((GObject*)(castitem))
{}


Connection::~Connection()
{}


Connection::CppClassType Connection::connection_class_; // initialize static member

GType Connection::get_type()
{
  return connection_class_.init().get_type();
}


GType Connection::get_base_type()
{
  return midgard_type_connection_get_type();
}

Connection::Connection()
:
  // Mark this class as non-derived to allow C++ vfuncs to be skipped.
  Glib::ObjectBase(0),
  Glib::Object(Glib::ConstructParams(connection_class_.init()))
{
  

}

void Connection::open_config(MidgardConfig * config)
{
midgard_connection_open_config(gobj(), config); 
}


#ifdef GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED
#endif //GLIBMM_DEFAULT_SIGNAL_HANDLERS_ENABLED

#ifdef GLIBMM_VFUNCS_ENABLED
#endif //GLIBMM_VFUNCS_ENABLED


} // namespace Midgard


